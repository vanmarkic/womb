---

---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>womb | ambient events & curation</title>
	</head>
	<body>
		<div class="darkness" id="darkness">
			<!-- Blurred figures emerging from darkness -->
			<div class="figure figure-1" data-figure="1"></div>
			<div class="figure figure-2" data-figure="2"></div>
			<div class="figure figure-3" data-figure="3"></div>
			<div class="figure figure-4" data-figure="4"></div>
			<div class="figure figure-5" data-figure="5"></div>
			<div class="figure figure-6" data-figure="6"></div>

			<!-- Content overlay -->
			<div class="content">
				<h1>womb</h1>
				<p class="tagline">ambient events & artist curation</p>
			</div>
		</div>
	</body>
</html>

<script>
	// Ambient sound engine using Web Audio API
	class AmbientSoundEngine {
		private audioContext: AudioContext | null = null;
		private isInitialized = false;
		private soundTimers: NodeJS.Timeout[] = [];
		private reverb: ConvolverNode | null = null;

		init() {
			if (this.isInitialized) return;

			// Initialize on first user interaction (browser autoplay policy)
			const initAudio = () => {
				this.audioContext = new AudioContext();
				this.createCathedralReverb();
				this.isInitialized = true;
				this.startAmbientSounds();
				document.removeEventListener('click', initAudio);
				document.removeEventListener('touchstart', initAudio);
			};

			document.addEventListener('click', initAudio, { once: true });
			document.addEventListener('touchstart', initAudio, { once: true });
		}

		// Create cathedral reverb impulse response
		private createCathedralReverb() {
			if (!this.audioContext) return;

			const sampleRate = this.audioContext.sampleRate;
			const length = sampleRate * 4; // 4 second reverb tail
			const impulse = this.audioContext.createBuffer(2, length, sampleRate);
			const leftChannel = impulse.getChannelData(0);
			const rightChannel = impulse.getChannelData(1);

			// Generate cathedral-like reverb with exponential decay
			for (let i = 0; i < length; i++) {
				const decay = Math.exp(-i / (sampleRate * 1.5));
				const noise = (Math.random() * 2 - 1) * decay;

				leftChannel[i] = noise * (1 + Math.sin(i / 500));
				rightChannel[i] = noise * (1 + Math.cos(i / 500));
			}

			this.reverb = this.audioContext.createConvolver();
			this.reverb.buffer = impulse;
		}

		// Generate swoosh sound (mid-low frequency sweep)
		private createSwoosh() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 1.2 + Math.random() * 2.5; // Wider range: 1.2-3.7s

			// Random frequency range
			const startFreq = 140 + Math.random() * 100; // 140-240Hz
			const endFreq = 60 + Math.random() * 80; // 60-140Hz

			const oscillator = this.audioContext.createOscillator();
			const gainNode = this.audioContext.createGain();
			const filter = this.audioContext.createBiquadFilter();
			const dryGain = this.audioContext.createGain();
			const wetGain = this.audioContext.createGain();

			oscillator.type = 'sine';
			oscillator.frequency.setValueAtTime(startFreq, now);
			oscillator.frequency.exponentialRampToValueAtTime(endFreq, now + duration);

			filter.type = 'lowpass';
			filter.frequency.setValueAtTime(900 + Math.random() * 600, now);
			filter.frequency.exponentialRampToValueAtTime(300 + Math.random() * 300, now + duration);

			// Base volume for low frequencies (140-240Hz range)
			const volume = 0.030 + Math.random() * 0.022; // Slightly increased for bass
			gainNode.gain.setValueAtTime(0, now);
			gainNode.gain.linearRampToValueAtTime(volume, now + 0.1 + Math.random() * 0.15);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			// Random reverb mix
			const wet = 0.5 + Math.random() * 0.4;
			dryGain.gain.value = 1 - wet;
			wetGain.gain.value = wet;

			oscillator.connect(filter);
			filter.connect(gainNode);
			gainNode.connect(dryGain);
			gainNode.connect(wetGain);
			dryGain.connect(this.audioContext.destination);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			oscillator.start(now);
			oscillator.stop(now + duration);
		}

		// Generate sweesh sound (higher frequency with noise)
		private createSweesh() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 0.8 + Math.random() * 2; // Wider range: 0.8-2.8s

			// Variable noise amount
			const noiseAmount = 0.05 + Math.random() * 0.12; // 0.05-0.17
			const bufferSize = this.audioContext.sampleRate * duration;
			const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
			const data = buffer.getChannelData(0);

			for (let i = 0; i < bufferSize; i++) {
				data[i] = (Math.random() * 2 - 1) * noiseAmount;
			}

			const noiseSource = this.audioContext.createBufferSource();
			noiseSource.buffer = buffer;

			const filter = this.audioContext.createBiquadFilter();
			filter.type = 'bandpass';
			const startFreq = 2800 + Math.random() * 1500; // 2800-4300Hz
			const endFreq = 800 + Math.random() * 600; // 800-1400Hz
			filter.frequency.setValueAtTime(startFreq, now);
			filter.frequency.exponentialRampToValueAtTime(endFreq, now + duration);
			filter.Q.value = 2 + Math.random() * 3; // Random Q: 2-5

			const gainNode = this.audioContext.createGain();
			const dryGain = this.audioContext.createGain();
			const wetGain = this.audioContext.createGain();

			// Frequency-dependent volume: 2800-4300Hz → much quieter
			const volume = 0.005 + Math.random() * 0.004; // Reduced ~50% for high freq
			gainNode.gain.setValueAtTime(0, now);
			gainNode.gain.linearRampToValueAtTime(volume, now + 0.05 + Math.random() * 0.1);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			// Random reverb mix
			const wet = 0.4 + Math.random() * 0.5;
			dryGain.gain.value = 1 - wet;
			wetGain.gain.value = wet;

			noiseSource.connect(filter);
			filter.connect(gainNode);
			gainNode.connect(dryGain);
			gainNode.connect(wetGain);
			dryGain.connect(this.audioContext.destination);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			noiseSource.start(now);
		}

		// Generate whisper sound (subtle breath-like noise)
		private createWhisper() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 1.5 + Math.random() * 2.5; // 1.5-4s

			const noiseAmount = 0.02 + Math.random() * 0.04;
			const bufferSize = this.audioContext.sampleRate * duration;
			const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
			const data = buffer.getChannelData(0);

			for (let i = 0; i < bufferSize; i++) {
				data[i] = (Math.random() * 2 - 1) * noiseAmount;
			}

			const noiseSource = this.audioContext.createBufferSource();
			noiseSource.buffer = buffer;

			const filter = this.audioContext.createBiquadFilter();
			filter.type = 'highpass';
			filter.frequency.setValueAtTime(1600 + Math.random() * 1000, now); // 1600-2600Hz

			const gainNode = this.audioContext.createGain();
			const wetGain = this.audioContext.createGain();

			// Frequency-dependent: 1600-2600Hz → quieter
			const volume = 0.004 + Math.random() * 0.004; // Further reduced for high freq
			gainNode.gain.setValueAtTime(0, now);
			gainNode.gain.linearRampToValueAtTime(volume, now + 0.2 + Math.random() * 0.3);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			wetGain.gain.value = 0.7 + Math.random() * 0.25;

			noiseSource.connect(filter);
			filter.connect(gainNode);
			gainNode.connect(wetGain);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			noiseSource.start(now);
		}

		// Generate shimmer sound (high frequency bell-like tone)
		private createShimmer() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 2 + Math.random() * 2; // 2-4s

			const oscillator = this.audioContext.createOscillator();
			const gainNode = this.audioContext.createGain();
			const wetGain = this.audioContext.createGain();

			oscillator.type = 'sine';
			const startFreq = 700 + Math.random() * 400; // 700-1100Hz
			const endFreq = startFreq * (1.5 + Math.random()); // 1.5x-2.5x higher (1050-2750Hz)
			oscillator.frequency.setValueAtTime(startFreq, now);
			oscillator.frequency.exponentialRampToValueAtTime(endFreq, now + duration);

			// Frequency-dependent: 700-2750Hz → moderate reduction
			const volume = 0.006 + Math.random() * 0.005; // Further reduced
			gainNode.gain.setValueAtTime(0, now);
			gainNode.gain.linearRampToValueAtTime(volume, now + 0.08 + Math.random() * 0.15);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			wetGain.gain.value = 0.75 + Math.random() * 0.2;

			oscillator.connect(gainNode);
			gainNode.connect(wetGain);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			oscillator.start(now);
			oscillator.stop(now + duration);
		}

		// Generate rumble sound (very low frequency)
		private createRumble() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 2.5 + Math.random() * 2.5; // 2.5-5s

			const oscillator = this.audioContext.createOscillator();
			const gainNode = this.audioContext.createGain();
			const filter = this.audioContext.createBiquadFilter();
			const dryGain = this.audioContext.createGain();
			const wetGain = this.audioContext.createGain();

			oscillator.type = 'sine';
			const startFreq = 50 + Math.random() * 30; // 50-80Hz
			const endFreq = 25 + Math.random() * 20; // 25-45Hz
			oscillator.frequency.setValueAtTime(startFreq, now);
			oscillator.frequency.exponentialRampToValueAtTime(endFreq, now + duration);

			filter.type = 'lowpass';
			filter.frequency.value = 120 + Math.random() * 80; // 120-200Hz

			const volume = 0.022 + Math.random() * 0.018;
			gainNode.gain.setValueAtTime(0, now);
			gainNode.gain.linearRampToValueAtTime(volume, now + 0.3 + Math.random() * 0.4);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			const wet = 0.3 + Math.random() * 0.4;
			dryGain.gain.value = 1 - wet;
			wetGain.gain.value = wet;

			oscillator.connect(filter);
			filter.connect(gainNode);
			gainNode.connect(dryGain);
			gainNode.connect(wetGain);
			dryGain.connect(this.audioContext.destination);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			oscillator.start(now);
			oscillator.stop(now + duration);
		}

		// Generate drift sound (sweeping mid-range)
		private createDrift() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 1.8 + Math.random() * 2; // 1.8-3.8s

			const oscillator = this.audioContext.createOscillator();
			const gainNode = this.audioContext.createGain();
			const filter = this.audioContext.createBiquadFilter();
			const wetGain = this.audioContext.createGain();

			oscillator.type = 'triangle';
			const startFreq = 250 + Math.random() * 150; // 250-400Hz
			const peakFreq = startFreq + 100 + Math.random() * 200; // Variable peak
			const endFreq = startFreq - 50 + Math.random() * 100; // Variable end
			oscillator.frequency.setValueAtTime(startFreq, now);
			oscillator.frequency.linearRampToValueAtTime(peakFreq, now + duration / 2);
			oscillator.frequency.linearRampToValueAtTime(endFreq, now + duration);

			filter.type = 'bandpass';
			filter.frequency.value = 400 + Math.random() * 300; // 400-700Hz
			filter.Q.value = 1.5 + Math.random() * 2; // 1.5-3.5

			// Frequency-dependent: 250-600Hz → mild reduction
			const volume = 0.014 + Math.random() * 0.010; // Slight increase (low-mid freq)
			gainNode.gain.setValueAtTime(0, now);
			gainNode.gain.linearRampToValueAtTime(volume, now + 0.15 + Math.random() * 0.25);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			wetGain.gain.value = 0.6 + Math.random() * 0.3;

			oscillator.connect(filter);
			filter.connect(gainNode);
			gainNode.connect(wetGain);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			oscillator.start(now);
			oscillator.stop(now + duration);
		}

		// Generate crack sound (short sharp glitch)
		private createCrack() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 0.03 + Math.random() * 0.07; // Very short: 30-100ms

			// Sharp noise burst
			const bufferSize = this.audioContext.sampleRate * duration;
			const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
			const data = buffer.getChannelData(0);

			for (let i = 0; i < bufferSize; i++) {
				// Exponential decay within the burst
				const decay = 1 - (i / bufferSize);
				data[i] = (Math.random() * 2 - 1) * decay * 0.3;
			}

			const noiseSource = this.audioContext.createBufferSource();
			noiseSource.buffer = buffer;

			const filter = this.audioContext.createBiquadFilter();
			filter.type = 'bandpass';
			filter.frequency.value = 800 + Math.random() * 2000; // 800-2800Hz
			filter.Q.value = 8 + Math.random() * 12; // Very resonant: 8-20

			const gainNode = this.audioContext.createGain();
			const wetGain = this.audioContext.createGain();

			// Softer attack, quick decay - INCREASED VOLUME with attack envelope
			const volume = 0.042 + Math.random() * 0.042; // Increased from 0.015-0.030 to 0.035-0.070
			const attackTime = 0.008 + Math.random() * 0.012; // 8-20ms attack time
			gainNode.gain.setValueAtTime(0.001, now);
			gainNode.gain.exponentialRampToValueAtTime(volume, now + attackTime);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			wetGain.gain.value = 0.6 + Math.random() * 0.3;

			noiseSource.connect(filter);
			filter.connect(gainNode);
			gainNode.connect(wetGain);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			noiseSource.start(now);
		}

		// Generate glitch sound (digital artifact)
		private createGlitch() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 0.05 + Math.random() * 0.15; // 50-200ms

			const oscillator = this.audioContext.createOscillator();
			const gainNode = this.audioContext.createGain();
			const wetGain = this.audioContext.createGain();

			// Random waveform for digital character
			const types: OscillatorType[] = ['square', 'sawtooth', 'triangle'];
			oscillator.type = types[Math.floor(Math.random() * types.length)];

			// Rapid frequency jump (glitchy)
			const freq1 = 200 + Math.random() * 1500;
			const freq2 = 200 + Math.random() * 1500;
			oscillator.frequency.setValueAtTime(freq1, now);
			oscillator.frequency.setValueAtTime(freq2, now + duration * 0.5);

			// Softer envelope - INCREASED VOLUME with attack envelope
			const volume = 0.030 + Math.random() * 0.030; // Increased from 0.01-0.022 to 0.025-0.050
			const attackTime = 0.010 + Math.random() * 0.015; // 10-25ms attack time
			gainNode.gain.setValueAtTime(0.001, now);
			gainNode.gain.exponentialRampToValueAtTime(volume, now + attackTime);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			wetGain.gain.value = 0.5 + Math.random() * 0.3;

			oscillator.connect(gainNode);
			gainNode.connect(wetGain);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			oscillator.start(now);
			oscillator.stop(now + duration);
		}

		// Generate crackle sound (vinyl-like or fire crackle)
		private createCrackle() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 0.15 + Math.random() * 0.35; // 150-500ms

			// Create short bursts of noise with random gaps
			const bufferSize = this.audioContext.sampleRate * duration;
			const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
			const data = buffer.getChannelData(0);

			// Fill with crackling pattern
			for (let i = 0; i < bufferSize; i++) {
				// Random bursts with gaps (crackle effect)
				if (Math.random() > 0.7) { // 30% chance of sound per sample
					const decay = 1 - (i / bufferSize);
					data[i] = (Math.random() * 2 - 1) * decay * 0.4;
				} else {
					data[i] = 0;
				}
			}

			const noiseSource = this.audioContext.createBufferSource();
			noiseSource.buffer = buffer;

			const filter = this.audioContext.createBiquadFilter();
			filter.type = 'highpass';
			filter.frequency.value = 1500 + Math.random() * 2000; // 1500-3500Hz

			const gainNode = this.audioContext.createGain();
			const dryGain = this.audioContext.createGain();
			const wetGain = this.audioContext.createGain();

			// INCREASED VOLUME with softer attack
			const volume = 0.024 + Math.random() * 0.022; // Increased from 0.008-0.015 to 0.020-0.038
			const attackTime = 0.015 + Math.random() * 0.020; // 15-35ms attack time for crackle
			gainNode.gain.setValueAtTime(0.001, now);
			gainNode.gain.exponentialRampToValueAtTime(volume, now + attackTime);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			// Less reverb for more intimate crackle
			dryGain.gain.value = 0.7;
			wetGain.gain.value = 0.3;

			noiseSource.connect(filter);
			filter.connect(gainNode);
			gainNode.connect(dryGain);
			gainNode.connect(wetGain);
			dryGain.connect(this.audioContext.destination);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			noiseSource.start(now);
		}

		// Start ambient sound loops with randomness
		private startAmbientSounds() {
			const figureTimings = [
				{ baseDuration: 25000, soundType: 0 },  // figure-1: swoosh
				{ baseDuration: 30000, soundType: 1 },  // figure-2: sweesh
				{ baseDuration: 35000, soundType: 2 },  // figure-3: whisper
				{ baseDuration: 28000, soundType: 3 },  // figure-4: shimmer
				{ baseDuration: 32000, soundType: 4 },  // figure-5: rumble
				{ baseDuration: 40000, soundType: 5 },  // figure-6: drift
			];

			const soundFunctions = [
				() => this.createSwoosh(),
				() => this.createSweesh(),
				() => this.createWhisper(),
				() => this.createShimmer(),
				() => this.createRumble(),
				() => this.createDrift(),
			];

			const glitchFunctions = [
				() => this.createCrack(),
				() => this.createGlitch(),
				() => this.createCrackle(),
			];

			figureTimings.forEach((timing) => {
				// Random initial delay
				const randomInitialDelay = Math.random() * 15000;

				const scheduleNextSound = () => {
					// Play primary sound
					soundFunctions[timing.soundType]();

					// Reduced chance to layer additional sounds (10% chance)
					if (Math.random() < 0.1) {
						const randomSound = Math.floor(Math.random() * soundFunctions.length);
						setTimeout(() => {
							soundFunctions[randomSound]();
						}, 500 + Math.random() * 2000);
					}

					// Schedule next sound with random variation (±40% of base duration)
					const variation = (Math.random() - 0.5) * 0.8;
					const nextDelay = timing.baseDuration * (1 + variation);

					const timer = setTimeout(scheduleNextSound, nextDelay);
					this.soundTimers.push(timer);
				};

				// Start the chain
				const initialTimer = setTimeout(scheduleNextSound, randomInitialDelay);
				this.soundTimers.push(initialTimer);
			});

			// Add glitch/crack sounds on separate random schedule
			const scheduleGlitches = () => {
				// Random glitch type
				const glitchFunc = glitchFunctions[Math.floor(Math.random() * glitchFunctions.length)];
				glitchFunc();

				// Next glitch in 45-120 seconds
				const nextGlitchDelay = 45000 + Math.random() * 75000;
				const timer = setTimeout(scheduleGlitches, nextGlitchDelay);
				this.soundTimers.push(timer);
			};

			// Start glitch chain after initial delay
			const glitchInitialDelay = 20000 + Math.random() * 30000; // 20-50s
			const glitchTimer = setTimeout(scheduleGlitches, glitchInitialDelay);
			this.soundTimers.push(glitchTimer);
		}

		destroy() {
			this.soundTimers.forEach(timer => clearTimeout(timer));
			this.soundTimers = [];
			if (this.audioContext) {
				this.audioContext.close();
			}
		}
	}

	// Initialize sound engine
	const soundEngine = new AmbientSoundEngine();
	soundEngine.init();

	// Keyboard controls to trigger sounds manually
	const keyToSoundMap = new Map();
	const allSounds = [
		(engine: any) => engine.createSwoosh(),
		(engine: any) => engine.createSweesh(),
		(engine: any) => engine.createWhisper(),
		(engine: any) => engine.createShimmer(),
		(engine: any) => engine.createRumble(),
		(engine: any) => engine.createDrift(),
		(engine: any) => engine.createCrack(),
		(engine: any) => engine.createGlitch(),
		(engine: any) => engine.createCrackle(),
	];

	window.addEventListener('keydown', (e) => {
		// Skip if any modifier key is pressed (Ctrl, Alt, Meta/Cmd)
		// This preserves browser shortcuts like Ctrl+T, Cmd+R, etc.
		if (e.ctrlKey || e.altKey || e.metaKey) {
			return;
		}

		// @ts-ignore - accessing private methods for keyboard control
		const engine = soundEngine as any;

		const key = e.key.toLowerCase();

		// Ignore special keys that shouldn't trigger sounds
		const ignoredKeys = [
			'shift', 'control', 'alt', 'meta', 'capslock', 'tab',
			'escape', 'f1', 'f2', 'f3', 'f4', 'f5', 'f6', 'f7', 'f8', 'f9', 'f10', 'f11', 'f12',
			'printscreen', 'scrolllock', 'pause', 'insert', 'home', 'end', 'pageup', 'pagedown',
		];

		if (ignoredKeys.includes(key)) {
			return;
		}

		// Specific key mappings (optional, for consistent behavior)
		const specificMappings: Record<string, () => void> = {
			'1': () => engine.createSwoosh(),
			'2': () => engine.createSweesh(),
			'3': () => engine.createWhisper(),
			'4': () => engine.createShimmer(),
			'5': () => engine.createRumble(),
			'6': () => engine.createDrift(),
			'7': () => engine.createCrack(),
			'8': () => engine.createGlitch(),
			'9': () => engine.createCrackle(),
		};

		// Check if this is a specific mapped key
		if (specificMappings[key]) {
			specificMappings[key]();
		} else {
			// Any other key: assign a consistent sound to this key
			if (!keyToSoundMap.has(key)) {
				// Assign sound based on key code for consistency
				const soundIndex = key.charCodeAt(0) % allSounds.length;
				keyToSoundMap.set(key, allSounds[soundIndex]);
			}

			// Play the assigned sound
			const soundFunc = keyToSoundMap.get(key);
			if (soundFunc) {
				soundFunc(engine);
			}
		}

		// Prevent default for space to avoid page scroll
		if (key === ' ') {
			e.preventDefault();
		}
	});

	// Touch/swipe controls for mobile
	let touchStartX = 0;
	let touchStartY = 0;
	let touchStartTime = 0;
	let activeTouches = new Set();
	let lastSoundTime = 0;
	let isAudioInitialized = false;

	window.addEventListener('touchstart', (e) => {
		// @ts-ignore
		const engine = soundEngine as any;

		// Initialize audio on first touch (browser autoplay policy)
		if (!isAudioInitialized && engine.audioContext) {
			isAudioInitialized = true;
		}

		touchStartTime = Date.now();

		// Handle each touch point
		for (let i = 0; i < e.touches.length; i++) {
			const touch = e.touches[i];
			const touchId = touch.identifier;

			if (!activeTouches.has(touchId)) {
				activeTouches.add(touchId);

				// Store first touch position
				if (i === 0) {
					touchStartX = touch.clientX;
					touchStartY = touch.clientY;
				}

				// Don't play sound on initial touch - wait for swipe
				// This allows swiping to be the primary interaction
			}
		}
	});

	window.addEventListener('touchmove', (e) => {
		// @ts-ignore
		const engine = soundEngine as any;

		// Prevent page scrolling while swiping for sound
		e.preventDefault();

		if (e.touches.length === 1) {
			const touch = e.touches[0];
			const deltaX = touch.clientX - touchStartX;
			const deltaY = touch.clientY - touchStartY;
			const distance = Math.sqrt(deltaX * deltaX + deltaY * deltaY);

			// Trigger sounds while swiping - reduced threshold to 50px for more responsive feedback
			// Also add timing throttle to prevent too many sounds at once
			const now = Date.now();
			if (distance > 50 && now - lastSoundTime > 300) {
				// Determine direction and play corresponding sound
				const angle = Math.atan2(deltaY, deltaX) * (180 / Math.PI);

				if (angle >= -45 && angle < 45) {
					// Right swipe - sweesh (high frequency)
					engine.createSweesh();
				} else if (angle >= 45 && angle < 135) {
					// Down swipe - rumble (low frequency)
					engine.createRumble();
				} else if (angle >= -135 && angle < -45) {
					// Up swipe - shimmer (bell-like)
					engine.createShimmer();
				} else {
					// Left swipe - swoosh (mid-low sweep)
					engine.createSwoosh();
				}

				lastSoundTime = now;
				touchStartX = touch.clientX;
				touchStartY = touch.clientY;
			}
		} else if (e.touches.length > 1) {
			// Multi-finger swipe - play layered sounds
			const now = Date.now();
			if (now - lastSoundTime > 400) {
				engine.createDrift();
				setTimeout(() => engine.createWhisper(), 100);
				lastSoundTime = now;
			}
		}
	}, { passive: false });

	window.addEventListener('touchend', (e) => {
		// @ts-ignore
		const engine = soundEngine as any;

		const touchDuration = Date.now() - touchStartTime;

		// Clear ended touches
		const currentTouchIds = new Set();
		for (let i = 0; i < e.touches.length; i++) {
			currentTouchIds.add(e.touches[i].identifier);
		}

		activeTouches.forEach(touchId => {
			if (!currentTouchIds.has(touchId)) {
				activeTouches.delete(touchId);
			}
		});

		// Quick tap (< 200ms) triggers random glitch sound
		if (touchDuration < 200 && e.changedTouches.length === 1) {
			const glitchSounds = [
				() => engine.createCrack(),
				() => engine.createGlitch(),
				() => engine.createCrackle(),
			];
			glitchSounds[Math.floor(Math.random() * glitchSounds.length)]();
		}
	});

	// Cleanup on page unload
	window.addEventListener('beforeunload', () => {
		soundEngine.destroy();
	});
</script>

<style>
	* {
		margin: 0;
		padding: 0;
		box-sizing: border-box;
	}

	html, body {
		width: 100%;
		height: 100%;
		overflow: hidden;
	}

	body {
		background: #0a0a0a;
		font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
		color: #e0e0e0;
	}

	.darkness {
		position: relative;
		width: 100%;
		height: 100vh;
		background: radial-gradient(ellipse at center, #1a1a1a 0%, #0a0a0a 70%);
		overflow: hidden;
	}

	/* Blurred figures - like strangers in a dark forest */
	.figure {
		position: absolute;
		border-radius: 50%;
		filter: blur(60px);
		opacity: 0;
		background: rgba(80, 80, 90, 0.5);
		animation-timing-function: ease-in-out;
		animation-iteration-count: infinite;
		animation-direction: alternate;
	}

	.figure-1 {
		width: 400px;
		height: 600px;
		top: 10%;
		left: 5%;
		background: rgba(70, 70, 85, 0.6);
		animation: emerge1 12s infinite;
	}

	.figure-2 {
		width: 350px;
		height: 550px;
		top: 40%;
		right: 10%;
		background: rgba(75, 75, 90, 0.5);
		animation: emerge2 15s infinite;
		animation-delay: -7.5s;
	}

	.figure-3 {
		width: 300px;
		height: 500px;
		bottom: 15%;
		left: 20%;
		background: rgba(65, 65, 80, 0.65);
		animation: emerge3 18s infinite;
		animation-delay: -9s;
	}

	.figure-4 {
		width: 450px;
		height: 650px;
		top: 25%;
		left: 45%;
		background: rgba(68, 68, 83, 0.55);
		animation: emerge4 14s infinite;
		animation-delay: -3.5s;
	}

	.figure-5 {
		width: 380px;
		height: 580px;
		bottom: 20%;
		right: 15%;
		background: rgba(72, 72, 87, 0.6);
		animation: emerge5 16s infinite;
		animation-delay: -12s;
	}

	.figure-6 {
		width: 320px;
		height: 520px;
		top: 60%;
		left: 35%;
		background: rgba(67, 67, 82, 0.58);
		animation: emerge6 20s infinite;
		animation-delay: -5s;
	}

	/* Staggered emergence animations with dark pastel color transitions */
	@keyframes emerge1 {
		0% {
			opacity: 0;
			transform: translate(0, 0) scale(0.9);
			background: rgba(60, 60, 65, 0.4);
		}
		50% {
			opacity: 0.6;
			transform: translate(-20px, 30px) scale(1.1);
			background: rgba(120, 95, 135, 0.7); /* brighter pastel purple */
		}
		100% {
			opacity: 0;
			transform: translate(-40px, 60px) scale(0.95);
			background: rgba(60, 60, 65, 0.4);
		}
	}

	@keyframes emerge2 {
		0% {
			opacity: 0;
			transform: translate(0, 0) scale(1);
			background: rgba(60, 60, 65, 0.4);
		}
		50% {
			opacity: 0.55;
			transform: translate(30px, -25px) scale(1.05);
			background: rgba(95, 115, 140, 0.65); /* brighter pastel blue */
		}
		100% {
			opacity: 0;
			transform: translate(60px, -50px) scale(0.9);
			background: rgba(60, 60, 65, 0.4);
		}
	}

	@keyframes emerge3 {
		0% {
			opacity: 0;
			transform: translate(0, 0) scale(0.95);
			background: rgba(60, 60, 65, 0.4);
		}
		50% {
			opacity: 0.58;
			transform: translate(25px, 20px) scale(1.08);
			background: rgba(110, 125, 100, 0.68); /* brighter pastel green */
		}
		100% {
			opacity: 0;
			transform: translate(50px, 40px) scale(1);
			background: rgba(60, 60, 65, 0.4);
		}
	}

	@keyframes emerge4 {
		0% {
			opacity: 0;
			transform: translate(0, 0) scale(1.05);
			background: rgba(60, 60, 65, 0.4);
		}
		50% {
			opacity: 0.52;
			transform: translate(-35px, -20px) scale(0.95);
			background: rgba(130, 100, 115, 0.62); /* brighter pastel rose */
		}
		100% {
			opacity: 0;
			transform: translate(-70px, -40px) scale(1.1);
			background: rgba(60, 60, 65, 0.4);
		}
	}

	@keyframes emerge5 {
		0% {
			opacity: 0;
			transform: translate(0, 0) scale(0.92);
			background: rgba(60, 60, 65, 0.4);
		}
		50% {
			opacity: 0.56;
			transform: translate(-25px, 35px) scale(1.06);
			background: rgba(125, 110, 95, 0.66); /* brighter pastel amber */
		}
		100% {
			opacity: 0;
			transform: translate(-50px, 70px) scale(0.98);
			background: rgba(60, 60, 65, 0.4);
		}
	}

	@keyframes emerge6 {
		0% {
			opacity: 0;
			transform: translate(0, 0) scale(1.02);
			background: rgba(60, 60, 65, 0.4);
		}
		50% {
			opacity: 0.54;
			transform: translate(40px, -30px) scale(0.93);
			background: rgba(105, 120, 125, 0.64); /* brighter pastel teal */
		}
		100% {
			opacity: 0;
			transform: translate(80px, -60px) scale(1.04);
			background: rgba(60, 60, 65, 0.4);
		}
	}

	/* Content styling */
	.content {
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		text-align: center;
		z-index: 10;
		text-shadow: 0 0 40px rgba(0, 0, 0, 0.9);
	}

	h1 {
		font-size: 6rem;
		font-weight: 200;
		letter-spacing: 0.3em;
		color: #d0d0d0;
		margin-bottom: 1rem;
		text-transform: lowercase;
		opacity: 0;
		animation: fadeInContent 3s ease-in forwards;
	}

	.tagline {
		font-size: 1rem;
		letter-spacing: 0.2em;
		color: #808080;
		font-weight: 300;
		text-transform: lowercase;
		opacity: 0;
		animation: fadeInContent 3s ease-in 1s forwards;
	}

	@keyframes fadeInContent {
		to {
			opacity: 1;
		}
	}

	/* Responsive adjustments */
	@media (max-width: 768px) {
		h1 {
			font-size: 3rem;
			letter-spacing: 0.2em;
		}

		.tagline {
			font-size: 0.8rem;
		}

		.figure {
			filter: blur(60px);
		}

		.figure-1, .figure-2, .figure-3,
		.figure-4, .figure-5, .figure-6 {
			width: 250px;
			height: 400px;
		}
	}
</style>
