---

---

<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" type="image/svg+xml" href="/favicon.svg" />
		<meta name="viewport" content="width=device-width" />
		<meta name="generator" content={Astro.generator} />
		<title>womb | ambient events & curation</title>
	</head>
	<body>
		<div class="darkness" id="darkness">
			<!-- Blurred figures emerging from darkness -->
			<div class="figure figure-1" data-figure="1"></div>
			<div class="figure figure-2" data-figure="2"></div>
			<div class="figure figure-3" data-figure="3"></div>
			<div class="figure figure-4" data-figure="4"></div>
			<div class="figure figure-5" data-figure="5"></div>
			<div class="figure figure-6" data-figure="6"></div>

			<!-- Content overlay -->
			<div class="content">
				<h1>womb</h1>
				<p class="tagline">ambient events & artist curation</p>
			</div>
		</div>
	</body>
</html>

<script>
	// Ambient sound engine using Web Audio API
	class AmbientSoundEngine {
		private audioContext: AudioContext | null = null;
		private isInitialized = false;
		private soundTimers: NodeJS.Timeout[] = [];
		private reverb: ConvolverNode | null = null;

		init() {
			if (this.isInitialized) return;

			// Initialize on first user interaction (browser autoplay policy)
			const initAudio = () => {
				this.audioContext = new AudioContext();
				this.createCathedralReverb();
				this.isInitialized = true;
				this.startAmbientSounds();
				document.removeEventListener('click', initAudio);
				document.removeEventListener('touchstart', initAudio);
			};

			document.addEventListener('click', initAudio, { once: true });
			document.addEventListener('touchstart', initAudio, { once: true });
		}

		// Create cathedral reverb impulse response
		private createCathedralReverb() {
			if (!this.audioContext) return;

			const sampleRate = this.audioContext.sampleRate;
			const length = sampleRate * 4; // 4 second reverb tail
			const impulse = this.audioContext.createBuffer(2, length, sampleRate);
			const leftChannel = impulse.getChannelData(0);
			const rightChannel = impulse.getChannelData(1);

			// Generate cathedral-like reverb with exponential decay
			for (let i = 0; i < length; i++) {
				const decay = Math.exp(-i / (sampleRate * 1.5));
				const noise = (Math.random() * 2 - 1) * decay;

				leftChannel[i] = noise * (1 + Math.sin(i / 500));
				rightChannel[i] = noise * (1 + Math.cos(i / 500));
			}

			this.reverb = this.audioContext.createConvolver();
			this.reverb.buffer = impulse;
		}

		// Generate swoosh sound (mid-low frequency sweep)
		private createSwoosh() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 1.2 + Math.random() * 2.5; // Wider range: 1.2-3.7s

			// Random frequency range
			const startFreq = 140 + Math.random() * 100; // 140-240Hz
			const endFreq = 60 + Math.random() * 80; // 60-140Hz

			const oscillator = this.audioContext.createOscillator();
			const gainNode = this.audioContext.createGain();
			const filter = this.audioContext.createBiquadFilter();
			const dryGain = this.audioContext.createGain();
			const wetGain = this.audioContext.createGain();

			oscillator.type = 'sine';
			oscillator.frequency.setValueAtTime(startFreq, now);
			oscillator.frequency.exponentialRampToValueAtTime(endFreq, now + duration);

			filter.type = 'lowpass';
			filter.frequency.setValueAtTime(900 + Math.random() * 600, now);
			filter.frequency.exponentialRampToValueAtTime(300 + Math.random() * 300, now + duration);

			// Base volume for low frequencies (140-240Hz range)
			const volume = 0.025 + Math.random() * 0.018; // Slightly increased for bass
			gainNode.gain.setValueAtTime(0, now);
			gainNode.gain.linearRampToValueAtTime(volume, now + 0.1 + Math.random() * 0.15);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			// Random reverb mix
			const wet = 0.5 + Math.random() * 0.4;
			dryGain.gain.value = 1 - wet;
			wetGain.gain.value = wet;

			oscillator.connect(filter);
			filter.connect(gainNode);
			gainNode.connect(dryGain);
			gainNode.connect(wetGain);
			dryGain.connect(this.audioContext.destination);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			oscillator.start(now);
			oscillator.stop(now + duration);
		}

		// Generate sweesh sound (higher frequency with noise)
		private createSweesh() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 0.8 + Math.random() * 2; // Wider range: 0.8-2.8s

			// Variable noise amount
			const noiseAmount = 0.05 + Math.random() * 0.12; // 0.05-0.17
			const bufferSize = this.audioContext.sampleRate * duration;
			const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
			const data = buffer.getChannelData(0);

			for (let i = 0; i < bufferSize; i++) {
				data[i] = (Math.random() * 2 - 1) * noiseAmount;
			}

			const noiseSource = this.audioContext.createBufferSource();
			noiseSource.buffer = buffer;

			const filter = this.audioContext.createBiquadFilter();
			filter.type = 'bandpass';
			const startFreq = 2800 + Math.random() * 1500; // 2800-4300Hz
			const endFreq = 800 + Math.random() * 600; // 800-1400Hz
			filter.frequency.setValueAtTime(startFreq, now);
			filter.frequency.exponentialRampToValueAtTime(endFreq, now + duration);
			filter.Q.value = 2 + Math.random() * 3; // Random Q: 2-5

			const gainNode = this.audioContext.createGain();
			const dryGain = this.audioContext.createGain();
			const wetGain = this.audioContext.createGain();

			// Frequency-dependent volume: 2800-4300Hz → much quieter
			const volume = 0.004 + Math.random() * 0.003; // Reduced ~50% for high freq
			gainNode.gain.setValueAtTime(0, now);
			gainNode.gain.linearRampToValueAtTime(volume, now + 0.05 + Math.random() * 0.1);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			// Random reverb mix
			const wet = 0.4 + Math.random() * 0.5;
			dryGain.gain.value = 1 - wet;
			wetGain.gain.value = wet;

			noiseSource.connect(filter);
			filter.connect(gainNode);
			gainNode.connect(dryGain);
			gainNode.connect(wetGain);
			dryGain.connect(this.audioContext.destination);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			noiseSource.start(now);
		}

		// Generate whisper sound (subtle breath-like noise)
		private createWhisper() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 1.5 + Math.random() * 2.5; // 1.5-4s

			const noiseAmount = 0.02 + Math.random() * 0.04;
			const bufferSize = this.audioContext.sampleRate * duration;
			const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
			const data = buffer.getChannelData(0);

			for (let i = 0; i < bufferSize; i++) {
				data[i] = (Math.random() * 2 - 1) * noiseAmount;
			}

			const noiseSource = this.audioContext.createBufferSource();
			noiseSource.buffer = buffer;

			const filter = this.audioContext.createBiquadFilter();
			filter.type = 'highpass';
			filter.frequency.setValueAtTime(1600 + Math.random() * 1000, now); // 1600-2600Hz

			const gainNode = this.audioContext.createGain();
			const wetGain = this.audioContext.createGain();

			// Frequency-dependent: 1600-2600Hz → quieter
			const volume = 0.003 + Math.random() * 0.003; // Further reduced for high freq
			gainNode.gain.setValueAtTime(0, now);
			gainNode.gain.linearRampToValueAtTime(volume, now + 0.2 + Math.random() * 0.3);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			wetGain.gain.value = 0.7 + Math.random() * 0.25;

			noiseSource.connect(filter);
			filter.connect(gainNode);
			gainNode.connect(wetGain);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			noiseSource.start(now);
		}

		// Generate shimmer sound (high frequency bell-like tone)
		private createShimmer() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 2 + Math.random() * 2; // 2-4s

			const oscillator = this.audioContext.createOscillator();
			const gainNode = this.audioContext.createGain();
			const wetGain = this.audioContext.createGain();

			oscillator.type = 'sine';
			const startFreq = 700 + Math.random() * 400; // 700-1100Hz
			const endFreq = startFreq * (1.5 + Math.random()); // 1.5x-2.5x higher (1050-2750Hz)
			oscillator.frequency.setValueAtTime(startFreq, now);
			oscillator.frequency.exponentialRampToValueAtTime(endFreq, now + duration);

			// Frequency-dependent: 700-2750Hz → moderate reduction
			const volume = 0.005 + Math.random() * 0.004; // Further reduced
			gainNode.gain.setValueAtTime(0, now);
			gainNode.gain.linearRampToValueAtTime(volume, now + 0.08 + Math.random() * 0.15);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			wetGain.gain.value = 0.75 + Math.random() * 0.2;

			oscillator.connect(gainNode);
			gainNode.connect(wetGain);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			oscillator.start(now);
			oscillator.stop(now + duration);
		}

		// Generate rumble sound (very low frequency)
		private createRumble() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 2.5 + Math.random() * 2.5; // 2.5-5s

			const oscillator = this.audioContext.createOscillator();
			const gainNode = this.audioContext.createGain();
			const filter = this.audioContext.createBiquadFilter();
			const dryGain = this.audioContext.createGain();
			const wetGain = this.audioContext.createGain();

			oscillator.type = 'sine';
			const startFreq = 50 + Math.random() * 30; // 50-80Hz
			const endFreq = 25 + Math.random() * 20; // 25-45Hz
			oscillator.frequency.setValueAtTime(startFreq, now);
			oscillator.frequency.exponentialRampToValueAtTime(endFreq, now + duration);

			filter.type = 'lowpass';
			filter.frequency.value = 120 + Math.random() * 80; // 120-200Hz

			const volume = 0.018 + Math.random() * 0.015;
			gainNode.gain.setValueAtTime(0, now);
			gainNode.gain.linearRampToValueAtTime(volume, now + 0.3 + Math.random() * 0.4);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			const wet = 0.3 + Math.random() * 0.4;
			dryGain.gain.value = 1 - wet;
			wetGain.gain.value = wet;

			oscillator.connect(filter);
			filter.connect(gainNode);
			gainNode.connect(dryGain);
			gainNode.connect(wetGain);
			dryGain.connect(this.audioContext.destination);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			oscillator.start(now);
			oscillator.stop(now + duration);
		}

		// Generate drift sound (sweeping mid-range)
		private createDrift() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 1.8 + Math.random() * 2; // 1.8-3.8s

			const oscillator = this.audioContext.createOscillator();
			const gainNode = this.audioContext.createGain();
			const filter = this.audioContext.createBiquadFilter();
			const wetGain = this.audioContext.createGain();

			oscillator.type = 'triangle';
			const startFreq = 250 + Math.random() * 150; // 250-400Hz
			const peakFreq = startFreq + 100 + Math.random() * 200; // Variable peak
			const endFreq = startFreq - 50 + Math.random() * 100; // Variable end
			oscillator.frequency.setValueAtTime(startFreq, now);
			oscillator.frequency.linearRampToValueAtTime(peakFreq, now + duration / 2);
			oscillator.frequency.linearRampToValueAtTime(endFreq, now + duration);

			filter.type = 'bandpass';
			filter.frequency.value = 400 + Math.random() * 300; // 400-700Hz
			filter.Q.value = 1.5 + Math.random() * 2; // 1.5-3.5

			// Frequency-dependent: 250-600Hz → mild reduction
			const volume = 0.012 + Math.random() * 0.008; // Slight increase (low-mid freq)
			gainNode.gain.setValueAtTime(0, now);
			gainNode.gain.linearRampToValueAtTime(volume, now + 0.15 + Math.random() * 0.25);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			wetGain.gain.value = 0.6 + Math.random() * 0.3;

			oscillator.connect(filter);
			filter.connect(gainNode);
			gainNode.connect(wetGain);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			oscillator.start(now);
			oscillator.stop(now + duration);
		}

		// Generate crack sound (short sharp glitch)
		private createCrack() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 0.03 + Math.random() * 0.07; // Very short: 30-100ms

			// Sharp noise burst
			const bufferSize = this.audioContext.sampleRate * duration;
			const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
			const data = buffer.getChannelData(0);

			for (let i = 0; i < bufferSize; i++) {
				// Exponential decay within the burst
				const decay = 1 - (i / bufferSize);
				data[i] = (Math.random() * 2 - 1) * decay * 0.3;
			}

			const noiseSource = this.audioContext.createBufferSource();
			noiseSource.buffer = buffer;

			const filter = this.audioContext.createBiquadFilter();
			filter.type = 'bandpass';
			filter.frequency.value = 800 + Math.random() * 2000; // 800-2800Hz
			filter.Q.value = 8 + Math.random() * 12; // Very resonant: 8-20

			const gainNode = this.audioContext.createGain();
			const wetGain = this.audioContext.createGain();

			// Sharp attack, quick decay - INCREASED VOLUME
			const volume = 0.035 + Math.random() * 0.035; // Increased from 0.015-0.030 to 0.035-0.070
			gainNode.gain.setValueAtTime(volume, now);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			wetGain.gain.value = 0.6 + Math.random() * 0.3;

			noiseSource.connect(filter);
			filter.connect(gainNode);
			gainNode.connect(wetGain);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			noiseSource.start(now);
		}

		// Generate glitch sound (digital artifact)
		private createGlitch() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 0.05 + Math.random() * 0.15; // 50-200ms

			const oscillator = this.audioContext.createOscillator();
			const gainNode = this.audioContext.createGain();
			const wetGain = this.audioContext.createGain();

			// Random waveform for digital character
			const types: OscillatorType[] = ['square', 'sawtooth', 'triangle'];
			oscillator.type = types[Math.floor(Math.random() * types.length)];

			// Rapid frequency jump (glitchy)
			const freq1 = 200 + Math.random() * 1500;
			const freq2 = 200 + Math.random() * 1500;
			oscillator.frequency.setValueAtTime(freq1, now);
			oscillator.frequency.setValueAtTime(freq2, now + duration * 0.5);

			// Sharp envelope - INCREASED VOLUME
			const volume = 0.025 + Math.random() * 0.025; // Increased from 0.01-0.022 to 0.025-0.050
			gainNode.gain.setValueAtTime(volume, now);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			wetGain.gain.value = 0.5 + Math.random() * 0.3;

			oscillator.connect(gainNode);
			gainNode.connect(wetGain);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			oscillator.start(now);
			oscillator.stop(now + duration);
		}

		// Generate crackle sound (vinyl-like or fire crackle)
		private createCrackle() {
			if (!this.audioContext || !this.reverb) return;

			const now = this.audioContext.currentTime;
			const duration = 0.15 + Math.random() * 0.35; // 150-500ms

			// Create short bursts of noise with random gaps
			const bufferSize = this.audioContext.sampleRate * duration;
			const buffer = this.audioContext.createBuffer(1, bufferSize, this.audioContext.sampleRate);
			const data = buffer.getChannelData(0);

			// Fill with crackling pattern
			for (let i = 0; i < bufferSize; i++) {
				// Random bursts with gaps (crackle effect)
				if (Math.random() > 0.7) { // 30% chance of sound per sample
					const decay = 1 - (i / bufferSize);
					data[i] = (Math.random() * 2 - 1) * decay * 0.4;
				} else {
					data[i] = 0;
				}
			}

			const noiseSource = this.audioContext.createBufferSource();
			noiseSource.buffer = buffer;

			const filter = this.audioContext.createBiquadFilter();
			filter.type = 'highpass';
			filter.frequency.value = 1500 + Math.random() * 2000; // 1500-3500Hz

			const gainNode = this.audioContext.createGain();
			const dryGain = this.audioContext.createGain();
			const wetGain = this.audioContext.createGain();

			// INCREASED VOLUME
			const volume = 0.020 + Math.random() * 0.018; // Increased from 0.008-0.015 to 0.020-0.038
			gainNode.gain.setValueAtTime(volume, now);
			gainNode.gain.exponentialRampToValueAtTime(0.001, now + duration);

			// Less reverb for more intimate crackle
			dryGain.gain.value = 0.7;
			wetGain.gain.value = 0.3;

			noiseSource.connect(filter);
			filter.connect(gainNode);
			gainNode.connect(dryGain);
			gainNode.connect(wetGain);
			dryGain.connect(this.audioContext.destination);
			wetGain.connect(this.reverb);
			this.reverb.connect(this.audioContext.destination);

			noiseSource.start(now);
		}

		// Start ambient sound loops with randomness
		private startAmbientSounds() {
			const figureTimings = [
				{ baseDuration: 25000, soundType: 0 },  // figure-1: swoosh
				{ baseDuration: 30000, soundType: 1 },  // figure-2: sweesh
				{ baseDuration: 35000, soundType: 2 },  // figure-3: whisper
				{ baseDuration: 28000, soundType: 3 },  // figure-4: shimmer
				{ baseDuration: 32000, soundType: 4 },  // figure-5: rumble
				{ baseDuration: 40000, soundType: 5 },  // figure-6: drift
			];

			const soundFunctions = [
				() => this.createSwoosh(),
				() => this.createSweesh(),
				() => this.createWhisper(),
				() => this.createShimmer(),
				() => this.createRumble(),
				() => this.createDrift(),
			];

			const glitchFunctions = [
				() => this.createCrack(),
				() => this.createGlitch(),
				() => this.createCrackle(),
			];

			figureTimings.forEach((timing) => {
				// Random initial delay
				const randomInitialDelay = Math.random() * 15000;

				const scheduleNextSound = () => {
					// Play primary sound
					soundFunctions[timing.soundType]();

					// Reduced chance to layer additional sounds (10% chance)
					if (Math.random() < 0.1) {
						const randomSound = Math.floor(Math.random() * soundFunctions.length);
						setTimeout(() => {
							soundFunctions[randomSound]();
						}, 500 + Math.random() * 2000);
					}

					// Schedule next sound with random variation (±40% of base duration)
					const variation = (Math.random() - 0.5) * 0.8;
					const nextDelay = timing.baseDuration * (1 + variation);

					const timer = setTimeout(scheduleNextSound, nextDelay);
					this.soundTimers.push(timer);
				};

				// Start the chain
				const initialTimer = setTimeout(scheduleNextSound, randomInitialDelay);
				this.soundTimers.push(initialTimer);
			});

			// Add glitch/crack sounds on separate random schedule
			const scheduleGlitches = () => {
				// Random glitch type
				const glitchFunc = glitchFunctions[Math.floor(Math.random() * glitchFunctions.length)];
				glitchFunc();

				// Next glitch in 45-120 seconds
				const nextGlitchDelay = 45000 + Math.random() * 75000;
				const timer = setTimeout(scheduleGlitches, nextGlitchDelay);
				this.soundTimers.push(timer);
			};

			// Start glitch chain after initial delay
			const glitchInitialDelay = 20000 + Math.random() * 30000; // 20-50s
			const glitchTimer = setTimeout(scheduleGlitches, glitchInitialDelay);
			this.soundTimers.push(glitchTimer);
		}

		destroy() {
			this.soundTimers.forEach(timer => clearTimeout(timer));
			this.soundTimers = [];
			if (this.audioContext) {
				this.audioContext.close();
			}
		}
	}

	// Initialize sound engine
	const soundEngine = new AmbientSoundEngine();
	soundEngine.init();

	// Cleanup on page unload
	window.addEventListener('beforeunload', () => {
		soundEngine.destroy();
	});
</script>

<style>
	* {
		margin: 0;
		padding: 0;
		box-sizing: border-box;
	}

	html, body {
		width: 100%;
		height: 100%;
		overflow: hidden;
	}

	body {
		background: #0a0a0a;
		font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
		color: #e0e0e0;
	}

	.darkness {
		position: relative;
		width: 100%;
		height: 100vh;
		background: radial-gradient(ellipse at center, #1a1a1a 0%, #0a0a0a 70%);
		overflow: hidden;
	}

	/* Blurred figures - like strangers in a dark forest */
	.figure {
		position: absolute;
		border-radius: 50%;
		filter: blur(60px);
		opacity: 0;
		background: rgba(80, 80, 90, 0.5);
		animation-timing-function: ease-in-out;
		animation-iteration-count: infinite;
		animation-direction: alternate;
	}

	.figure-1 {
		width: 400px;
		height: 600px;
		top: 10%;
		left: 5%;
		background: rgba(70, 70, 85, 0.6);
		animation: emerge1 12s infinite;
	}

	.figure-2 {
		width: 350px;
		height: 550px;
		top: 40%;
		right: 10%;
		background: rgba(75, 75, 90, 0.5);
		animation: emerge2 15s infinite;
		animation-delay: -7.5s;
	}

	.figure-3 {
		width: 300px;
		height: 500px;
		bottom: 15%;
		left: 20%;
		background: rgba(65, 65, 80, 0.65);
		animation: emerge3 18s infinite;
		animation-delay: -9s;
	}

	.figure-4 {
		width: 450px;
		height: 650px;
		top: 25%;
		left: 45%;
		background: rgba(68, 68, 83, 0.55);
		animation: emerge4 14s infinite;
		animation-delay: -3.5s;
	}

	.figure-5 {
		width: 380px;
		height: 580px;
		bottom: 20%;
		right: 15%;
		background: rgba(72, 72, 87, 0.6);
		animation: emerge5 16s infinite;
		animation-delay: -12s;
	}

	.figure-6 {
		width: 320px;
		height: 520px;
		top: 60%;
		left: 35%;
		background: rgba(67, 67, 82, 0.58);
		animation: emerge6 20s infinite;
		animation-delay: -5s;
	}

	/* Staggered emergence animations with dark pastel color transitions */
	@keyframes emerge1 {
		0% {
			opacity: 0;
			transform: translate(0, 0) scale(0.9);
			background: rgba(60, 60, 65, 0.4);
		}
		50% {
			opacity: 0.6;
			transform: translate(-20px, 30px) scale(1.1);
			background: rgba(120, 95, 135, 0.7); /* brighter pastel purple */
		}
		100% {
			opacity: 0;
			transform: translate(-40px, 60px) scale(0.95);
			background: rgba(60, 60, 65, 0.4);
		}
	}

	@keyframes emerge2 {
		0% {
			opacity: 0;
			transform: translate(0, 0) scale(1);
			background: rgba(60, 60, 65, 0.4);
		}
		50% {
			opacity: 0.55;
			transform: translate(30px, -25px) scale(1.05);
			background: rgba(95, 115, 140, 0.65); /* brighter pastel blue */
		}
		100% {
			opacity: 0;
			transform: translate(60px, -50px) scale(0.9);
			background: rgba(60, 60, 65, 0.4);
		}
	}

	@keyframes emerge3 {
		0% {
			opacity: 0;
			transform: translate(0, 0) scale(0.95);
			background: rgba(60, 60, 65, 0.4);
		}
		50% {
			opacity: 0.58;
			transform: translate(25px, 20px) scale(1.08);
			background: rgba(110, 125, 100, 0.68); /* brighter pastel green */
		}
		100% {
			opacity: 0;
			transform: translate(50px, 40px) scale(1);
			background: rgba(60, 60, 65, 0.4);
		}
	}

	@keyframes emerge4 {
		0% {
			opacity: 0;
			transform: translate(0, 0) scale(1.05);
			background: rgba(60, 60, 65, 0.4);
		}
		50% {
			opacity: 0.52;
			transform: translate(-35px, -20px) scale(0.95);
			background: rgba(130, 100, 115, 0.62); /* brighter pastel rose */
		}
		100% {
			opacity: 0;
			transform: translate(-70px, -40px) scale(1.1);
			background: rgba(60, 60, 65, 0.4);
		}
	}

	@keyframes emerge5 {
		0% {
			opacity: 0;
			transform: translate(0, 0) scale(0.92);
			background: rgba(60, 60, 65, 0.4);
		}
		50% {
			opacity: 0.56;
			transform: translate(-25px, 35px) scale(1.06);
			background: rgba(125, 110, 95, 0.66); /* brighter pastel amber */
		}
		100% {
			opacity: 0;
			transform: translate(-50px, 70px) scale(0.98);
			background: rgba(60, 60, 65, 0.4);
		}
	}

	@keyframes emerge6 {
		0% {
			opacity: 0;
			transform: translate(0, 0) scale(1.02);
			background: rgba(60, 60, 65, 0.4);
		}
		50% {
			opacity: 0.54;
			transform: translate(40px, -30px) scale(0.93);
			background: rgba(105, 120, 125, 0.64); /* brighter pastel teal */
		}
		100% {
			opacity: 0;
			transform: translate(80px, -60px) scale(1.04);
			background: rgba(60, 60, 65, 0.4);
		}
	}

	/* Content styling */
	.content {
		position: absolute;
		top: 50%;
		left: 50%;
		transform: translate(-50%, -50%);
		text-align: center;
		z-index: 10;
		text-shadow: 0 0 40px rgba(0, 0, 0, 0.9);
	}

	h1 {
		font-size: 6rem;
		font-weight: 200;
		letter-spacing: 0.3em;
		color: #d0d0d0;
		margin-bottom: 1rem;
		text-transform: lowercase;
		opacity: 0;
		animation: fadeInContent 3s ease-in forwards;
	}

	.tagline {
		font-size: 1rem;
		letter-spacing: 0.2em;
		color: #808080;
		font-weight: 300;
		text-transform: lowercase;
		opacity: 0;
		animation: fadeInContent 3s ease-in 1s forwards;
	}

	@keyframes fadeInContent {
		to {
			opacity: 1;
		}
	}

	/* Responsive adjustments */
	@media (max-width: 768px) {
		h1 {
			font-size: 3rem;
			letter-spacing: 0.2em;
		}

		.tagline {
			font-size: 0.8rem;
		}

		.figure {
			filter: blur(60px);
		}

		.figure-1, .figure-2, .figure-3,
		.figure-4, .figure-5, .figure-6 {
			width: 250px;
			height: 400px;
		}
	}
</style>
